// __tests__/messaging-api.test.ts
import { messagingApi } from '@/lib/messaging-api';
import { MessageStatus } from '@/types/messaging';
import { expect, describe, test, beforeEach, vi } from 'vitest';

// Mock fetch for all tests
global.fetch = vi.fn();

// Helper to set up fetch mock response
function mockFetchResponse(status: number, responseData: any) {
  return Promise.resolve({
    ok: status >= 200 && status < 300,
    status,
    json: () => Promise.resolve(responseData),
  });
}

// Reset mocks before each test
beforeEach(() => {
  vi.resetAllMocks();
});

describe('Messaging API Client', () => {
  // File Attachment Tests
  describe('File Attachments', () => {
    test('uploadMessageAttachment should upload file and return attachment data', async () => {
      const mockFile = new File(['test content'], 'test.txt', { type: 'text/plain' });
      const mockResponse = { 
        success: true, 
        attachment: { 
          id: 'test-id', 
          name: 'test.txt', 
          type: 'text/plain', 
          size: 12,
          url: 'https://example.com/test.txt',
          thumbnailUrl: null
        } 
      };
      
      // Mock the fetch implementation for this test
      (global.fetch as any).mockImplementationOnce(() => 
        mockFetchResponse(200, mockResponse)
      );
      
      const result = await messagingApi.uploadMessageAttachment(
        mockFile, 
        'conversation-id', 
        'message-id'
      );
      
      // Verify fetch was called with the right arguments
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/messages/upload',
        expect.objectContaining({
          method: 'POST',
          body: expect.any(FormData),
        })
      );
      
      // Verify we get the expected result
      expect(result).toEqual(mockResponse.attachment);
    });
    
    test('deleteMessageAttachment should delete attachment and return success', async () => {
      const mockResponse = { success: true };
      
      (global.fetch as any).mockImplementationOnce(() => 
        mockFetchResponse(200, mockResponse)
      );
      
      const result = await messagingApi.deleteMessageAttachment('attachment-id');
      
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/messages/attachment/attachment-id',
        expect.objectContaining({
          method: 'DELETE',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
        })
      );
      
      expect(result).toBe(true);
    });
    
    test('getMessageAttachments should return attachment list', async () => {
      const mockAttachments = [
        { 
          id: 'attachment-1', 
          name: 'file1.txt', 
          type: 'text/plain',
          size: 100,
          url: 'https://example.com/file1.txt',
          thumbnailUrl: null
        },
        { 
          id: 'attachment-2', 
          name: 'image.jpg', 
          type: 'image/jpeg',
          size: 1024,
          url: 'https://example.com/image.jpg',
          thumbnailUrl: 'https://example.com/thumb_image.jpg'
        }
      ];
      
      const mockResponse = { 
        success: true, 
        attachments: mockAttachments 
      };
      
      (global.fetch as any).mockImplementationOnce(() => 
        mockFetchResponse(200, mockResponse)
      );
      
      const result = await messagingApi.getMessageAttachments('message-id');
      
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/messages/attachments?messageId=message-id',
        expect.objectContaining({
          method: 'GET',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
        })
      );
      
      expect(result).toEqual(mockAttachments);
    });
  });
  
  // Message Status Tests
  describe('Message Status', () => {
    test('updateMessageStatus should update status and return successfully', async () => {
      const mockResponse = { success: true };
      
      (global.fetch as any).mockImplementationOnce(() => 
        mockFetchResponse(200, mockResponse)
      );
      
      await messagingApi.updateMessageStatus('message-id', MessageStatus.READ, 'user-id');
      
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/messages/status',
        expect.objectContaining({
          method: 'PATCH',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
          body: JSON.stringify({ 
            messageId: 'message-id', 
            status: MessageStatus.READ, 
            userId: 'user-id' 
          }),
        })
      );
    });
    
    test('updateMessageStatus should handle errors', async () => {
      const errorMessage = 'Not authorized to update this message';
      const mockResponse = { error: errorMessage };
      
      (global.fetch as any).mockImplementationOnce(() => 
        mockFetchResponse(403, mockResponse)
      );
      
      await expect(
        messagingApi.updateMessageStatus('message-id', MessageStatus.READ, 'user-id')
      ).rejects.toThrow(errorMessage);
    });
  });
  
  // Typing Indicator Tests
  describe('Typing Indicators', () => {
    test('sendTypingIndicator should send typing status', async () => {
      const mockResponse = { success: true };
      
      (global.fetch as any).mockImplementationOnce(() => 
        mockFetchResponse(200, mockResponse)
      );
      
      await messagingApi.sendTypingIndicator('conversation-id', 'user-id', true);
      
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/messages/typing',
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
          body: JSON.stringify({ 
            conversationId: 'conversation-id', 
            userId: 'user-id', 
            isTyping: true 
          }),
        })
      );
    });
  });
  
  // Conversation Archive Tests
  describe('Conversation Archive', () => {
    test('setConversationArchiveStatus should archive conversation', async () => {
      const mockResponse = { success: true };
      
      (global.fetch as any).mockImplementationOnce(() => 
        mockFetchResponse(200, mockResponse)
      );
      
      await messagingApi.setConversationArchiveStatus('conversation-id', 'user-id', true);
      
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/conversations/archive',
        expect.objectContaining({
          method: 'PATCH',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
          body: JSON.stringify({ 
            conversationId: 'conversation-id', 
            userId: 'user-id', 
            isArchived: true 
          }),
        })
      );
    });
  });
  
  // Read Status Tests
  describe('Conversation Read Status', () => {
    test('markConversationAsRead should mark conversation as read', async () => {
      const mockResponse = { success: true };
      
      (global.fetch as any).mockImplementationOnce(() => 
        mockFetchResponse(200, mockResponse)
      );
      
      await messagingApi.markConversationAsRead('conversation-id', 'user-id');
      
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/conversations/read',
        expect.objectContaining({
          method: 'PATCH',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
          body: JSON.stringify({ 
            conversationId: 'conversation-id', 
            userId: 'user-id' 
          }),
        })
      );
    });
  });
  
  // Conversation Preferences Tests
  describe('Conversation Preferences', () => {
    test('getConversationPreferences should return user preferences', async () => {
      const mockPreferences = {
        isPinned: true,
        pinnedOrder: 1,
        isStarred: false,
        isArchived: false,
        notificationsEnabled: true,
      };

      const mockResponse = {
        preferences: mockPreferences
      };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(200, mockResponse)
      );

      const result = await messagingApi.getConversationPreferences('conversation-id');

      expect(global.fetch).toHaveBeenCalledWith(
        '/api/conversations/preferences?conversationId=conversation-id',
        expect.objectContaining({
          method: 'GET',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
        })
      );

      expect(result).toEqual(mockPreferences);
    });

    test('updateConversationPreferences should update and return preferences', async () => {
      const updatedPreferences = {
        isPinned: true,
        pinnedOrder: 2,
        isStarred: true,
        isArchived: false,
        notificationsEnabled: false,
      };

      const mockResponse = {
        success: true,
        preferences: updatedPreferences
      };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(200, mockResponse)
      );

      const result = await messagingApi.updateConversationPreferences('conversation-id', {
        isPinned: true,
        pinnedOrder: 2,
        isStarred: true,
      });

      expect(global.fetch).toHaveBeenCalledWith(
        '/api/conversations/preferences',
        expect.objectContaining({
          method: 'PATCH',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
          body: JSON.stringify({
            conversationId: 'conversation-id',
            isPinned: true,
            pinnedOrder: 2,
            isStarred: true,
          }),
        })
      );

      expect(result).toEqual(updatedPreferences);
    });
  });

  // Grouped Conversations Tests
  describe('Grouped Conversations', () => {
    test('getGroupedConversations should return conversations grouped by type', async () => {
      const mockGrouped = {
        direct: [
          { id: 'conv-1', type: 'direct', participants: ['user-1', 'user-2'] },
          { id: 'conv-2', type: 'direct', participants: ['user-1', 'user-3'] },
        ],
        rooms: [
          { id: 'conv-3', type: 'room', roomId: 'room-1', participants: ['user-1', 'user-2', 'user-3'] },
        ],
      };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(200, mockGrouped)
      );

      const result = await messagingApi.getGroupedConversations();

      expect(global.fetch).toHaveBeenCalledWith(
        '/api/conversations/get?grouped=true'
      );

      expect(result).toEqual(mockGrouped);
    });

    test('getGroupedConversations should support includeArchived option', async () => {
      const mockGrouped = {
        direct: [],
        rooms: [],
      };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(200, mockGrouped)
      );

      await messagingApi.getGroupedConversations({ includeArchived: true });

      expect(global.fetch).toHaveBeenCalledWith(
        '/api/conversations/get?grouped=true&includeArchived=true'
      );
    });
  });

  // Pinned Conversations Tests
  describe('Pinned Conversations', () => {
    test('getPinnedConversations should return pinned conversations', async () => {
      const mockPinned = {
        conversations: [
          { id: 'conv-1', type: 'direct', participants: ['user-1', 'user-2'], isPinned: true },
          { id: 'conv-3', type: 'room', roomId: 'room-1', participants: ['user-1', 'user-2', 'user-3'], isPinned: true },
        ],
      };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(200, mockPinned)
      );

      const result = await messagingApi.getPinnedConversations();

      expect(global.fetch).toHaveBeenCalledWith(
        '/api/conversations/get?pinned=true'
      );

      expect(result).toEqual(mockPinned.conversations);
    });
  });

  // Unread Summary Tests
  describe('Unread Summary', () => {
    test('getUnreadSummary should return unread counts by type', async () => {
      const mockSummary = {
        totalUnread: 15,
        directUnread: 8,
        roomUnread: 7,
      };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(200, mockSummary)
      );

      const result = await messagingApi.getUnreadSummary();

      expect(global.fetch).toHaveBeenCalledWith(
        '/api/conversations/get?summary=true'
      );

      expect(result).toEqual(mockSummary);
    });

    test('getUnreadSummary should default to zero counts on empty response', async () => {
      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(200, {})
      );

      const result = await messagingApi.getUnreadSummary();

      expect(result).toEqual({
        totalUnread: 0,
        directUnread: 0,
        roomUnread: 0,
      });
    });
  });

  // Error Handling Tests
  describe('Error Handling', () => {
    test('API should handle network errors', async () => {
      (global.fetch as any).mockImplementationOnce(() =>
        Promise.reject(new Error('Network error'))
      );

      await expect(
        messagingApi.getMessageAttachments('message-id')
      ).rejects.toThrow('Network error');
    });

    test('API should handle API errors with error messages', async () => {
      const errorResponse = { error: 'Resource not found' };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(404, errorResponse)
      );

      await expect(
        messagingApi.getMessageAttachments('message-id')
      ).rejects.toThrow(errorResponse.error);
    });

    test('getConversationPreferences should handle errors', async () => {
      const errorMessage = 'Conversation not found';
      const mockResponse = { error: errorMessage };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(404, mockResponse)
      );

      await expect(
        messagingApi.getConversationPreferences('invalid-id')
      ).rejects.toThrow(errorMessage);
    });

    test('updateConversationPreferences should handle validation errors', async () => {
      const errorMessage = 'At least one preference field must be provided';
      const mockResponse = { error: errorMessage };

      (global.fetch as any).mockImplementationOnce(() =>
        mockFetchResponse(400, mockResponse)
      );

      await expect(
        messagingApi.updateConversationPreferences('conversation-id', {})
      ).rejects.toThrow(errorMessage);
    });
  });
});
